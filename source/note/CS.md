---
title: 计算机领域一般性知识
date: 2021-12-16 08:00:00
---


VSCODE修改默认终端
--------------------

按下`Ctrl+P`打开功能搜索栏，输入`Terminal: Select Default Profile`，然后选择自己需要的终端。


CPU如何实现时间片切换
----------------------------

显然CPU在执行过程中并没有时间的概念，也不可能在执行进程的代码的时候，在每一条指令后检查是否已经执行了指定的时间。所以时间片的切换显然是通过中断触发的。

通过单独的计时模块可以按照一定的时间间隔触发时钟中断（例如每隔1ms触发一次），从而CPU在执行完当前指令后通过响应中断的方式通知操作系统判断当前进程是否指向了足够长的时间。


ELF文件加载过程
--------------------------

从ELF文件的结构来看，似乎有很多不同的段，似乎如果要执行ELF文件，还需要进行解析过程。但需要注意到ELF的两个常见的格式，即可重定位目标文件和可执行目标文件。对于可重定位目标文件，由于需要重定位，因此有很多辅助的信息表。但是对于可执行目标文件，少了很多辅助段。

而且代码中的.text段和.data段时间上也是相邻的，分别将这两个段加载到内存之中即可构建进程在内存中的状态。整个过程中只需要简单的解析每个段所在的位置即可，不需要进行复杂的分析过程。

当然，这个解析过程肯定还是需要加载器进行处理的，并不是硬件直接完成。

静态链接过程
---------------

静态链接过程的核心是将多个代码片段合并为一个代码片段，并且适当的重写其中的符号引用地址。由于最终的文件包含所有的代码，因此所以的符号最终的位置都是可以确定的，只需要通过适当的计算即可得到对应的地址。


动态链接库的加载
--------------------

使用动态链接库的程序相比于静态链接的程序，由于有动态链接的内容，因此显然并不能像静态链接的程序一样直接复制text段和data段带内存中即可执行。假设当前的用户程序A动态链接了一个库lib，则在启动A的过程中需要执行如下的一些操作：

1. 加载A的代码和数据到内存之中
2. 根据A中描述的动态链接库列表，使用动态链接器加载lib的代码和数据到内存之中
3. 重写A中关于lib的符号，使其指向lib的实际地址

之后使用了动态链接库的的用户程序A就可以像静态链接的程序一样运行了。而且通过虚拟内存技术可以使得动态链接器的代码段在不同的进程中共享，从而减少应用程序的体积，减少运行时的内存消耗。


与位置无关代码
---------------------

动态链接库和静态链接库的一个重要区别就是动态链接库的代码要求是位置无关代码（Position Independent Code， PIC）。这主要有两个原因

1. 动态链接库中的代码不和用户代码合并到一个文件之中，因此不能知道最终会被加载到内存的那个位置，不能假定绝对地址
2. 动态链接库中的代码可能被多个进程共享，因此不能保证总是加载到同一个内存位置

即使使用了虚拟地址技术，也不能假定一定加载到某个位置，否则在位置分配上容易产生空间浪费或者冲突等问题，带来管理上的负担。

动态链接库中需要处理位置的地方主要是对全局变量和外部函数的访问。对于模块内部的变量和函数，显然在编译过程中就可以确定相对位置了，只有外部的变量和函数由于也可能是动态加载的而不确定位置。

为了实现对其他模块的符号的访问，动态链接库的代码中再data段的开头设置了一个表格（Global Offset Table， GOT），表格中记录了外部符号的绝对地址。其中的绝对地址在程序加载的时候由动态链接器更新。而在代码中所有需要访问外部符号的地方，都改为先访问GOT中的条目，再通过其中的记录得到对应的符号。

由于库中的代码和GOT表的位置是可以编译时确定的，因此只需要在代码中设置对应的偏移地址即可。从而保证了动态链接库无论加载到那个位置都只需要修改GOT，而不需要修改代码中的引用。

对于动态链接库和静态链接库，可以看到两者本质上都是解决重定位问题，只不过静态链接库因为具有所有的代码，可以在链接过程中直接完成计算，而动态链接库在程序加载以后才具有对应的代码，才完成对应的计算。


动态链接库方法的延迟绑定
------------------------------

对于动态链接库中的变量，在加载的时候就完成GOT表的计算，实现绑定效果。对于函数，动态链接库并没有采用同样的方式，而是采取了延迟绑定的方法。

延迟绑定的核心还是利用GOT表，代码中直接call GOT表对应条目中存储的地址。当此函数是第一次调用的时候，GOT表格中的地址指向启动动态链接器的代码，使得动态链接器加载对应的代码，并修改GOT中的对应条目，使其直接指向加载的函数。最后动态链接器将控制权转移到对应的函数。

第二次访问时，再次call GOT表对应条目中存储的地址时，就可以直接跳转到对应的函数。

相比于变量的两次访问，通过延迟加载可以使的方法调用除了第一次需要额外逻辑后只需要一次额外的GOT表访问。



前端校验和后端校验
--------------------------

前端校验的目的是防止用户错误输入。 后端校验的目的是方式恶意攻击。

所以一些关键的校验既需要前端校验也需要后端校验



x86-64 Core体系结构历史
-----------------------

x86-64处理器是对x86-32处理器的扩展. 第一个支持x86-32的处理器是1985年推出的Intel 80386微处理器. 80386是对16位体系的80286的扩展, 具有32位寄存器和4GB虚拟地址空间, 使用一个独立的, 称为80387的浮点单元进行浮点运算.

1993年推出的奔腾CPU基于P5架构, 支持MMX技术, 能够对64位大小的寄存处执行单指令多数据(SIMD操作. 1995年推出P6架构, 并在1997年推出的奔腾II中引入三路超标量设计, 使得CPU能够平均在每个周期内解码, 分派和执行三条不同的指令. 此外还引入了无序指令执行, 改进的分支预测等优化.

1999年推出的奔腾III也基于P6架构, 并且支持一种称为 Streaming SIMD Extension, SSE的指令集, 从而能够对8个128位的寄存处进行操作. 2006年, Intel推出Core架构, 支持SSE3和SSE4.1指令集. 2008年推出Nehalem架构, 再次引入超线程技术并支持SSE4.2指令集. 2011年推出Sandy Bridge架构, 引入一种新得SIMD技术, 称为Advanced Vector Extension, AVX. 2013年推出Haswell架构, 支持AVX2指令集和FMA(乘法加法融合)操作. 2017年推出的Skylake-X架构支持了AVX-512指令集, 能够操作512位的寄存器.

与此同期, AMD在2003推出一系列基于K8架构的CPU, 能够支持MMX, SSE和SSE2指令集. 2007年推出K10架构, 支持一种对SSE的扩展指令集SSE4a. 2011年推出Bulldozer架构, 支持SSE3, SSE4.1, SSE4.2, SSE4a和AVX指令集.2017年推出Zen架构, 支持AVX2指令集.

- [The History Of Intel CPUs: Updated!](https://www.tomshardware.com/picturestory/710-history-of-intel-cpus.html)

POSIX接口
--------------

POSIX是 Portable Operating System Interface for uniX的缩写, 即可移植操作系统接口. 在POSIX接口提出以前, 存在很多不同的操作系统, 这些操作系统提供的接口也都不尽相同, 因此对程序开发带来了很大的困难.

POSIX标准通常由C语言的库实现, 例如glibc和musl等. 在C语言层面通过调用POSIX接口实现在不同的操作系统上转换为合适的系统调用.
