---
title: Go语言笔记之内置模块
date: 2021-07-11 09:31:50
categories: Go语言笔记
tags: 
    - Go
cover_picture: images/go.png
---
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script> -->


本文介绍Go语言中常见的数据结构的基本使用, 包括定长数组, 变长数组, 哈希表等结构


数组
-----------------

数组是基础的数据结构, 不同于C语言中所有数组本质上都是指针的实现, 在Go语言中数组既包含类型又包含长度, 类型和长度完全相同的数组才是为同一个类型.

### 初始化

数组可以直接初始化, 也可以不指定长度, 由编译器推导数组的长度, 例如

```go
arr1 := [3]int{1, 2, 3}
arr2 := [...]int{1, 2, 3}
```

> 注意: 不可使用`[]int{1,2,3}`的形式初始化, 因为这是切片的语法

数组初始化时可以直接指定某个位置的值, 使用此方式时, 没有被指定的位置默认使用零值, 例如

```go
a := [...]string{0:"A", 25:"Z"}
//a = [A                         Z]
```

### 实现细节

- 如果数组中的元素可以比较, 那么可以直接使用`==`比较两个数组是否相同. 此时当且仅当数组中每个元素都对应相等时, 两个数组才相等
- GO语言中数组是值类型, 采用拷贝传递, 因此向函数传递数组会导致数组被复制

> 由于数组拷贝的特性, 一般不会将数组作为参数, 而是将可变的切片作为参数.



切片(变长数组)
-------------------

Go的数组是值语义, 而C系列的语言对于数组都是视为引用语义, 因此直接将数组作为函数参数传递时会遇到很多问题, 例如值传递导致较高的拷贝开销, 无法在函数内修改数组等.

为了解决这一问题, Go引入了切片数据结构. 切片可以视为对数组的一个片段的引用. 切片是一个轻量级的数据结构, 其中只包含了引用数据的指针和切片的长度, 以及切片剩余的容量, 切片结构示意图如下所示

![](/images/go/slice.png)

> 由于每个变量在编译时就可以确定类型, 因此切片中不需要存储类型信息.

> 但是反射的时候还是需要类型信息的, 关于反射如何实现, 可以参考反射相关的章节

### 初始化

可以使用如下的方式定义切片

```go
var s1 []int  // 直接声明一个切片, 不指向任何数组

s2 := make([]int, 12) // 使用make函数创建切片并指定初始长度, 相当于同时分配了数组空间

s :=[]int{1,2,3 } // 使用字面量直接初始化并赋值
```

其中的make函数的原型为`make([]T, length, capacity)`, 长度和容量值得是当前的实际长度和可以存放数据的最大长度. 

> 使用`len()`和`cap()`函数获取切片的长度和容量

### 切片操作

切片的截取操作遵循Python中的切片语法. 也可以从数组等数据结构中产生切片, 从而实现对数组中部分数据的**引用**. 例如

```go
arr  := [10]int {0,1,2,3,4,5,6,7,8,9}

// 创建数组的引用, 容量是数组的剩余空间
var numA []int = arr[6:8]   // Pointer=0xc0000161c0 len=2 cap=4 slice=[6 7]

// 添加数据, 指针不变, 说明原地修改数据
numA = append(numA, 1)      // Pointer=0xc0000161c0 len=3 cap=4 slice=[6 7 1]

// 添加更多数据, 操作数组范围, 进行了复制
numA = append(numA, 2,3,4,5)// Pointer=0xc00000e400 len=7 cap=8 slice=[6 7 1 2 3 4 5]
```

> 使用`append()`和`copy()`对切片进行添加和复制操作


向切片中添加数据时, 如果没有达到容量的限制则直接添加, 否则拷贝数据到新分配的空间中. 

拷贝数据时是否预留空间是不确定的, 因此不能假定其特性类似于ArrayList. 如果需要添加很多数据, 建议提前分配合适大小的空间.

### 切片与内存泄露

由于切片是底层数组的一个引用，因此即使只有非常小的一个切片引用，也会导致整个底层数组无法被释放。如果不想出现这种问题，可以考虑在返回切片的时候创建一个切片的拷贝，从而切断与原始底层数组的联系。

此外，与Java实现堆栈的情形类似，如果切片中持有了对象的指针，而删除指针的时候没有手动置为nil，也会导致对象被延迟垃圾回收。

> 如果切片本身的生命周期就比较短, 那么就不必特别担心这个问题了


### 其他

切片作为一种引用类型, 其零值是nil. 但与Java的集合类型一样, 最好使用空集合代替零值, 可以通过`make([]int, 0, 10)`的方式创建一个有容量的空切片.


哈希表
------------

Go语言中使用内置的map实现哈希表结果. map显然也是一个引用语义的数据结构.

### 初始化

可以直接使用列表初始化一个map, 也可以使用make函数创建map. 使用make函数时能够提前分配空间, 从而减少扩容操作产生的性能消耗.

```go
// 直接列表初始化
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}


// 先分配空间, 再复制
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

map会自动扩容, 但创建是设置一个合适的初始值有助于减少扩容的性能消耗.  map是引用类型, 因此传递map对象与传递一个指针的代价相同. 


### 操作数据

由于map中能够存储任意类型的数据, 因此获取数据时可以采用如下的两种方式

```go
// 如果数据不存在返回对应类型的零值, 如果本身就是零值, 也会返回零值
val = dict[key]

// 如果数据存在, ok值为true, 否则为false
val, ok = dict[key]

// 仅判断是否存在数据
_, ok = dict[key]


// 与if混合使用
if goString, ok := dict["go"]; !ok{
    /* ... */ 
}

// 遍历
for k, v := range dict {
    fmt.Printf("Key: %s Value: %s\n", k, v)
}


//删除
delete(dict, "go") 
```
