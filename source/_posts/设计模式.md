---
title: 设计模式
date: 2017-11-05 21:58:52
tags:
	- 设计模式
---

自己也写了很多代码了, 最近在对一个以前写的Android项目进行重构, 在重构的过程中发现, 无论怎样调整各种类之间的关系, 在某些方面有所改进的同时, 在另外一些方面产生了严重的问题, 总是不能取得一个合适的平衡点. 而且有一些方案起初感觉良好, 可随着代码的重构, 才发现这些方案存在严重缺陷, 完全不可行.

在这样的重构过程中, 我花费了很多时间, 但没有取得什么良好的效果, 甚至还凭空增加了代码的复杂度. 实际上, 这些问题的本质都是设计模式的问题, 通过学习设计模式, 我们可以学习到程序设计的一些客观规律, 从而使程序更易于维护和修改.

本文将记录设计模式的有关知识. 依据设计模式来进行设计和开发, 能够使程序更加灵活, 更好的适应客户复杂而多变的需求.

目录
----------
- [设计模式的基本原则](#设计模式的基本原则)
- [单例模式](#单例模式)


设计模式的基本原则
--------------------

### 面向对象设计原则
以下的一些原则是在面向对象设计的过程中, 应该遵守的基本原则虽然这些规则都不是强制的要求, 但是遵守这些规律可以减少我们对项目维护的难度. 设计模式的种类非常多, 所以我们更多的应该思考各种模式的本质, 从而做的自发的使用需要的模式.


原则      | 含义
---------|-----------------------------------------------------
单一职责  | 系统中的每一个类都应该只做一件事情
开闭原则  | 一个对象对扩展开放, 对修改关闭(通过增加代码完成新功能)
依赖倒转  | 抽象不应该依赖于细节, 细节应该依赖于抽象
里氏替换  | 任何出现抽象类的地方都可以使用它的子类替代
合成复用  | 优先使用组合而不是继承
迪米特原则| 一个对象对另外一个对象的了解要尽可能少

单一原则使得一个类只有一个改变原因, 从而不会扩大修改对系统的影响.



单例模式
-------------
 
### 使用场景
如果某个类只需要一个全局的唯一实例, 则使用单例模式.  典型的场景是数据库的连接, 日志的输出文件, 这些类在整个程序中, 都只需要唯一的实例. 


### 实现代码
``` Java
public class Singleton{
    private static Singleton instance = null;

    private Singleton() { }

    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 要点分析
- 通过是否为空判断, 使得第一次调用此函数的时候, 需要花费时间初始化, 其他时候调用都直接返回实例
- 保证了始终使用同一个实例, 从而一定程度保证了数据的一致性
- 保证了全局只有一个实例, 一定程度的节省了系统开销



策略模式
----------------

策略模式是一种对算法的封装, 同一个问题可以使用不同的算法实现, 这些算法具有相同的输入与输出结构.


观察者模式
--------------

通过注册的方式对某一对象添加观察者, 当对象发生变化时通知注册的观察者.


装饰模式
-----------

Python中的装饰器就是装饰模式的典型应用. 装饰模式在准寻开闭原则的基础上, 通过在原有类的基础上附加功能实现对扩展的开放. 

在Java中`io`包定义的各类输入输出流也是一种典型的装饰模式, 通过对基础数据流的组装, 可以实现缓冲, 结构解析等能力.


工厂模式
-----------

工厂模式的目标是将对象的创建细节封装. 工厂模式提供一个简单的方法用于创建对象, 根据输入的不同返回某一个具体的子类. 而外部代码时钟使用接口进行操作, 而不关心内部的具体实现.


代理模式
------------

代理模式的目标是控制对象的访问. 代理模式通过将请求转发到底层的类实现具体的功能, 在转发的过程中可以对请求进行控制, 从而实现额外的逻辑.