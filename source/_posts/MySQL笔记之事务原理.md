---
title: MySQL笔记之事务原理
date: 2021-05-10 16:27:49
categories: MySQL笔记
tags:
    - MySQL
    - 数据库
cover_picture: images/mysql.png
---
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script> -->



事务
-----------------

### 事务特性

MySQL采取默认提交(AUTOCOMMIT)模式, 即除非显式的开始一个事务, 则每个语句都是为一个事务在执行后立即提交. 事务的基本特征是ACID, 即原子性, 一致性, 隔离性和持久性. 

**原子性**表明一个事务必须视为一个不可分割的最小执行单位, 其中的操作要么同时成功, 要么同时失败. 

**一致性**表明数据库总是一致的从一个状态转移到另一个状态, 而不会导致数据出现不一致. 

**隔离性**表明一个事务的操作在提交之前应该对其他事务不可见. 虽然事务要求有隔离性, 但MySQL对隔离性提供了不同的等级, 因此对隔离性也有不同的表现. MySQL默认采取的隔离级别为可重复读.

**持久性**表明一个事务的操作一旦提交到数据库, 则即使数据库崩溃, 数据也不会丢失. 但实际上, 显然并不存在可以保证绝对不丢失数据的数据库, 而持久性也存在不同的等级.

SQL标准规定了四种隔离级别, 每种级别都规定了一个事务的修改, 在其他事务内的可见性. 低级别的隔离通常具有更高的并发性并且系统开销也更低. 关于事务的基本特性和隔离级别, 可以参考之前的博客[数据库原理之事务并发控制](https://lizec.top/2019/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/).

实现了ACID特性的数据库比没有实现ACID特性的数据库需要消耗更多CPU性能, 内存空间和磁盘空间. MySQL由于可以选择不同的存储引擎, 因此可以自由的选择是否需要事务相关的特性, 从而更灵活的适应需求.

### 隐式提交

默认情况下, MySQL是自动提交的, 即如果没有明确表示开始一个事务, 则每个语句都视为一个单独的事务. 但即使手动k开启了事务, 当执行某些特定操作时, 此操作之前的操作还是会被提交, 这一特性称为隐式提交. 这类操作包括定义或修改数据库结构, 在事务中开启新的事务, 手动锁定表, 加载数据, 复制数据等. 

### 保存点

在事务中执行多步操作时, 可以指定一些保存点, 从而在回滚的时候, 不回滚全部操作, 而是回滚到指定的保存点. 例如

```
BEGIN;
SELECT ...;
UPDATE ...;
SAVEPOINT A;
UPDATE ...;
ROLLBACK TO A;  #回滚到保存点A
```


redo日志
-----------------

由于硬盘的IO速度比较慢, 因此MySQL并不会每次修改操作都将修改写入硬盘, 而是会将结果先缓存到内存之中, 在某个时机再整页的写入数据. 由于数据写入操作的滞后性, 存在数据修改后还未写入之前, 数据库发生崩溃的可能性. MySQL使用redo日志来解决这一问题. 

当事务提交时, MySQL并不会将数据的修改立刻写入硬盘, 但会将相应的redo日志立即写入硬盘. 由于写日志操作是顺序IO, 因此相比于更随机的写入页面, 写入日志的性能更高. 当数据库发生崩溃时, 数据库可以根据redo日志恢复已经提交的事务, 从而保证事务的一致性和持久性. 

### redo日志格式

redo日志是一种物理机制, 其中并不是记录相关的SQL语句, 而是记录了页面修改情况的详细信息.  redo日志的行格式中包含很多类型, 有的类型指示简单的记录那个页面的那个偏移位置有修改, 有的类型就会记录一些更复杂的信息. 

一条插入语句可能只需要在某个位置加入一个记录, 因此只需要一条redo日志即可. 但在另外一些情况下, 插入数据可能导致页面分裂, 进而引发一系列的修改, 就可能产生数十条redo日志. 因此实际写入redo日志的过程也需要保证原子性, 例如上述的数十条redo日志, 要保证要么不写入, 要么全部写入, 否则就可能导致数据恢复到不正确的中间位置. 

MySQL中将底层的一次原子操作称为一个Mini-Transaction（MTR）, 例如前面提到了插入数据后导致页面分裂的一系列操作就是一个MTR. redo日志的写入过程以MTR为基本单位. 


### redo日志写入过程

redo日志也存在缓冲区, 其中按照512字节分割为不同的block. 在事务的执行过程中, 会不断的产生redo日志, 这些redo日志先按照组存在在某个地方, 等一组任务完成以后再写入到redo日志的缓冲区中. 

缓冲区内的redo日志在如下的一些时机会被刷入硬盘
1. 缓冲区空间不足
2. 事务提交
3. 后台专门刷新的线程
4. 关闭服务器
5. checkpoint

### redo日志文件组

redo日志在磁盘上对应了几个文件, 一般的命名格式类似`ib_logfile0`, `ib_logfile1`. 这些日志文件会被循环写入, 后写入的日志会覆盖以前写入的日志. 

redo日志中使用log sequence number(lsn)来记录日志的写入位置, 从而判断哪些位置日志已经失效, 哪些位置的日志还需要保存. 




undo日志
--------------

### 事务ID

每个开启的事务都会被分配一个事务ID, 如果这个事务不进行任何修改, 则ID默认为0.  



MVCC机制
-----------------

MySQL的大多数支持事务的存储引擎都采用多版本并发控制机制来实现行级锁. 其他的数据库系统也都实现了MVCC机制, 但具体的实现可能不尽相同, 因为MVCC并没有规定实现标准.

MVCC机制的核心是创建一个快照视图, 从而从某个时刻开始, 事务根据快照读取数据时就好像数据不在发生变化, 从而实现可重复读. 

MySQL中InnoDB的MVCC机制的实现方法的核心在于每行数据后有两个隐藏字段, 一个表示创建时间, 一个表示删除时间, 两个字段都使用系统版本号进行标识. 开启一个事务时, 系统版本号会自动递增, 并且事务以此时的系统版本号作为此事务的版本号. 并且在执行不同操作时, 有如下的约束

**SELECT操作**只读取创建时间的版本号小于等于当前版本号的数据和删除时间为未定义或大于当前事务版本号的数据. 这样可以保证读取的数据要么在事务开始前已经创建, 要么在事务开始后才被删除.

**INSERT操作**将当前事务的版本号作为新插入数据的创建时间版本号.

**DELETE操作**将当前事务的版本号作为删除数据的删除时间版本号

**UPDATE操作**先插入一条数据, 然后将原来的数据删除.

按照如上的约定, 即可实现可重复读. 如果放宽SELECT操作对创建时间的限制, 那么就可以将隔离级别降低为读已提交. 通过MVCC机制, 可以使大部分读操作不加锁的实现.

对于写操作还是需要加锁, 否则可能导致事务特性被破坏. 对于`select for update`等操作, 由于读取的是当前数据, 因此可能与直接的select读取数据不一致. 但`select for update`语句本身加了锁, 因此从第一次执行后, 还是能够保证可重复读.

由于快照不变, 因此也可以保证不出现幻读的问题. 但对于当前读, 由于读取的事实数据, 因此还是有可能出现幻读. 对于幻读问题, MySQL采用间隙锁来解决.

- [一文搞懂InnoDB MVCC机制](https://zhuanlan.zhihu.com/p/231947511)


 
锁机制
-----------------

InnoDB采用两段锁协议, 在事务过程中随时可能加锁, 并且在事务结束时统一释放所有的锁. InnoDB会根据隔离级别, 在需要的时候自动加锁.

由于引入了锁机制, 因此事务之间可能存在死锁. InnoDB等存储引擎实现了死锁检测和死锁超时机制. 当出现死锁时, InnoDB会回滚持有最少行级排它锁的事务. 锁的行为与顺序和存储引擎有关, 同样的执行语句, 在不同的存储引擎上可能有不同的执行情况. 语句本身和存储引擎的实现都可能导致死锁. 

### 间隙锁

- [MySQL的锁机制 - 记录锁、间隙锁、临键锁](https://zhuanlan.zhihu.com/p/48269420)
- [Mysql 间隙锁原理，以及Repeatable Read隔离级别下可以防止幻读原理(百度)](https://www.cnblogs.com/aspirant/p/9177978.html)