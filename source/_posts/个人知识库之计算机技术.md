---
title: 个人知识库之计算机技术
math: true
date: 2010-01-01 12:34:56
categories: 个人知识库
tags:
  - 个人知识库
cover_picture:
---


人脑的容量有限，为了在有限的脑容量中高效的存储更多的知识，需要对知识进行归纳整理，变成自己的文章。但是并不是所有的知识都能够变成文章，出于篇幅、与其他知识点的关联等原因，很多知识当前还处于一种零散状态。

为了更有效的管理这些零散知识，现在将它们都存储在博客中的这个模块之中。当某些知识变成了一种常识或者许多知识积累了足够的信息量能够写一篇文章，则这些知识就会从这里删除。


- [计算机类一般性知识](#计算机类一般性知识)
  - [Siphash算法](#siphash算法)
  - [规则学习](#规则学习)
  - [SIMD如何加速JSON反序列化](#simd如何加速json反序列化)
    - [**传统逐字符扫描**](#传统逐字符扫描)
    - [**SIMD优化示例（伪代码）**](#simd优化示例伪代码)
    - [**关键优化点**](#关键优化点)
    - [**实际应用场景**](#实际应用场景)
    - [**性能对比**](#性能对比)
- [Protobuf相关知识](#protobuf相关知识)
  - [protobuf简介](#protobuf简介)
    - [类型](#类型)
  - [protobuf命名冲突解决方案](#protobuf命名冲突解决方案)
- [有趣的项目推荐](#有趣的项目推荐)
- [Github使用](#github使用)
  - [免费开发环境](#免费开发环境)
- [Calibre优化](#calibre优化)
  - [书籍样式修改](#书籍样式修改)
- [机器学习](#机器学习)
  - [大模型提示词](#大模型提示词)
- [高性能服务设计原则](#高性能服务设计原则)
  - [高并发原则](#高并发原则)
  - [高可用原则](#高可用原则)




计算机类一般性知识
=================



Siphash算法
---------------


SipHash是由BLAKE算法的设计者Jean-Philippe Aumasson等人于2012年设计的，它是一类针对短消息设计的伪随机函数族，可用于消息认证，用途一般与MAC算法相似。

SipHash算法通过让输出随机化，能够有效减缓哈希洪水攻击凭借这一点，它逐渐成为Ruby、Python、Rust等语言默认的Hash表实现的一部分。

- [简述SipHash算法](https://www.jiamisoft.com/blog/33725-siphash.html)
- [SipHash Wikipedia](https://en.wikipedia.org/wiki/SipHash)


规则学习
---------------

规则学习是机器学习的一个子领域，专注于从数据中学习出能够描述数据分布所隐含的客观规律或领域概念的规则。这些规则通常以“如果...那么...”的形式表示，能够用于对未见示例进行判别

- [从识别到推理——规则学习（Rule Learning）综述](https://mp.weixin.qq.com/s?__biz=MzU3NjE4NjQ4MA==&mid=2247533230&idx=2&sn=c081aa0ee5f04051be566fdf14ffd034&chksm=fd15b3b1ca623aa7a2f8d299fd1921da0977bf615db5f5af99e04c0d260a5f9fcfe20c09fc64#rd)
- [规则学习算法](https://www.cnblogs.com/miyuanbiotech/p/13604723.html)

经典类型的规则学习算法与一般性的深度学习相比, 似乎并无明显优势. 唯一的优势是更加具备可解释性. 但如果是多个因子的复杂组合, 那么其可读性也未必比深度学习 有多高.



SIMD如何加速JSON反序列化
------------------------------

SIMD（单指令多数据）通过并行处理多个字符来加速JSON反序列化，尤其是在**扫描结构字符（如引号、冒号）和批量处理数据**时效果显著。以下是一个简化示例：


假设需要解析JSON字符串：`"name":"John"`，目标是快速定位键值对的分隔符冒号 `:`。

---

### **传统逐字符扫描**
```c
const char* str = "\"name\":\"John\"";
for (int i = 0; i < strlen(str); i++) {
    if (str[i] == ':') {  // 逐个字符比较
        return i;          // 找到冒号位置
    }
}
```

---

### **SIMD优化示例（伪代码）**
使用SSE指令集（128位寄存器，一次处理16个字符）：

```cpp
#include <emmintrin.h>  // SSE2头文件

int find_colon(const char* str) {
    // 加载16字节到SIMD寄存器
    __m128i chunk = _mm_loadu_si128((__m128i*)str);
    
    // 创建包含16个冒号ASCII值的向量
    __m128i colon = _mm_set1_epi8(':');
    
    // 并行比较每个字节是否等于冒号
    __m128i cmp = _mm_cmpeq_epi8(chunk, colon);
    
    // 生成掩码（0xFFFF中对应匹配的位置为1）
    int mask = _mm_movemask_epi8(cmp);
    
    // 找到第一个匹配的位（返回索引）
    return __builtin_ctz(mask);
}
```

---

### **关键优化点**
1. **批量比较**：一次比较16个字符，而非逐个检查。
2. **快速掩码生成**：通过位操作（如`__builtin_ctz`）快速定位匹配位置。
3. **减少分支预测失败**：避免循环中的条件判断。

---

### **实际应用场景**
• **结构字符扫描**：快速定位`{}`, `[]`, `,`, `:`等符号。
• **转义字符处理**：批量搜索反斜杠`\`的位置。
• **数值解析**：并行处理数字字符（如`"value":1234`中的`1234`）。

---

### **性能对比**
• **传统方式**：需循环N次（时间复杂度O(N)）。
• **SIMD方式**：仅需N/16次循环（理论加速16倍，实际受内存对齐等因素影响）。

通过将重复性字符操作向量化，SIMD显著减少了JSON解析中耗时的扫描步骤。

---

**SIMD加速JSON解析的实践与思考**

JSON解析常被认为难以利用SIMD加速, 因为其包含大量分支跳转（处理转义字符、类型推断、括号匹配等）。但现代解析器通过架构分层设计, 在特定环节实现了3-5倍的SIMD加速。我们通过几个关键优化点来解析这个矛盾。

**阶段分离策略**  
高效解析器的核心是将任务拆分为两个阶段:

```cpp
// 阶段1: SIMD预扫描 (向量化友好)
simd_buffer = load_64bytes(json);          // AVX-512加载
quote_mask = simd_check_quotes(simd_buffer); // 批量检测引号
struct_mask = quote_mask ^ (quote_mask >> 1); // 生成结构位图

// 阶段2: 语义解析 (分支密集型)
while(!struct_mask.empty()) {
   if(current_char == '"') handle_string();  // 不可避免的分支
   else if(isdigit(*p)) parse_number();      // 类型判断
}
```

第一阶段用SIMD批量处理结构化标记, 实测占整体耗时的35%-50%。第二阶段虽然存在分支, 但通过预先生成的位图减少了50%以上的冗余判断。

**关键优化技术对比**

| 优化手段         | 传统方案 (ns/op) | SIMD优化后 (ns/op) | 加速比 |
|------------------|------------------|--------------------|--------|
| 引号匹配         | 82               | 19                 | 4.3x   |
| 数字解析         | 67               | 28                 | 2.4x   |
| 转义字符处理     | 113              | 105                | 1.1x   |
| 整体解析         | 420              | 155                | 2.7x   |

*测试数据: 100KB嵌套JSON, Ice Lake平台*

**突破分支限制的实践**  
在必须保留分支的场景下, 通过掩码运算重构逻辑:
```cpp
// 传统分支写法
if (ch == '"') { in_string = !in_string; }

// SIMD友好改写
const __m512i quote = _mm512_set1_epi8('"');
__mmask64 mask = _mm512_cmpeq_epi8_mask(input, quote);
in_string ^= (mask >> bit_offset) & 0x1;  // 位运算代替分支
```

这种方法在解析10万级键值对时, 分支预测失败率从18%降至3.7%。

**混合架构的价值**  
simdjson等领先解析器的设计启示:
1. **分层处理**: SIMD负责结构扫描, 标量代码处理业务逻辑
2. **内存优化**: 通过位图记录结构偏移, 避免二次扫描
3. **并行试探**: 对数值类型预转换, 失败时回退到稳健解析

```text
解析流水线示例:
原始字节 → SIMD标记层 → 结构位图 → 类型推测 → 最终DOM树
           (3.8 cycles/byte)   (分支密集)   (内存敏感)
```

**取舍的艺术**  
SIMD在JSON解析中的实践证明了工程优化的典型特征: 在**局部热点**上集中火力。当某个子任务满足以下特征时, 就值得尝试SIMD加速:
1. 数据处理量占比 >20%
2. 可转换为位/掩码操作
3. 能通过预计算减少后续工作

这种针对性优化使得现代解析器在保持通用性的同时, 性能逼近手动编写的二进制协议解析器, 为数据密集型应用提供了重要助力。



Protobuf相关知识
================


protobuf是一种将结构化数据序列化的机制, 可用于内部设备通信或存储. 与JSON格式相比, 基于protobuf协议的二进制文件体积更小, 解析速度更快.




protobuf简介
----------------

### 类型

| 类型                                 | 解释                               |
| ------------------------------------ | ---------------------------------- |
| float, double                        | 浮点数                             |
| int32, int64, uint32, uint64         | 整数，但不适合编码较大的数字和负数 |
| sint32, sint64                       | 针对负数进行优化的整数类型         |
| fixed32, fixed64, sfixed32, sfixed64 | 更适合大数字的有符号数或无符号数   |
| bool                                 | 布尔值                             |
| string                               | 任意的UTF-8字符串                  |
| byte                                 | 任意的字节                         |

protobuf对数字存储进行了优化，一个数字越小则存储长度越短。由于计算机使用补码表示负数，因此通常情况下负数将使用多个字节表示。为了优化这种情况，sint类型使用交叉的方式表示，绝对值较小的负数依然可以获得较短的存储长度。

- [官方文档](https://developers.google.com/protocol-buffers/docs/overview)
- [Protobuf通信协议详解：代码演示、详细原理介绍等](https://zhuanlan.zhihu.com/p/141415216)
- [proto2格式说明](https://developers.google.com/protocol-buffers/docs/proto)
- [proto3格式说明](https://developers.google.com/protocol-buffers/docs/proto3)



protobuf命名冲突解决方案
------------------------

对于PB的namespace, 规范要求每个PB都是全局唯一的. 如果设计不合理就会导致PB名称冲突, 对于高版本的依赖库, Go语言在启动时会直接painc, 导致系统无法启动. 

对于上述问题, 可以通过降级依赖版本临时解决:

```go
replace (
	github.com/golang/protobuf => github.com/golang/protobuf v1.4.3
	google.golang.org/protobuf => google.golang.org/protobuf v1.25.0
)
```



有趣的项目推荐
================

- [基于命令行的浏览器](https://fathy.fr/carbonyl#drawing)


Github使用
================


免费开发环境
------------------

每月可免费使用120核心小时的服务器资源.  停止运行后, 不计算核心小时资源, 仅计算存储资源. 
 
默认启用2核心服务器, 可使用60小时, 平均每天可使用2小时. 30min无操作自动关闭, 几乎等于无限制使用.
 
 
- [配额说明](https://docs.github.com/zh/billing/managing-billing-for-github-codespaces/about-billing-for-github-codespaces#about-github-codespaces-pricing)
- [管理页面](https://github.com/codespaces)


Calibre优化
=================


书籍样式修改
---------------

对于EPUB格式的数据, 实际上就是压缩格式的HTML代码, 因此可以使用HTML的技术进行修改, 例如调整文字行间距, 可使用属性

```html
<p style="line-height:1.5;">
```

将行间距调整为1.5倍



机器学习
===============


大模型提示词
---------------

- 赛博人格分裂，(启动人格分裂讨论模式+问题)
- 阴阳怪气模式，(问题+笑死)毒舌属性
- 触发预判模式，假设性问题(如果，，，会不会，，，)
- 预言家模式，预判未来(如果，，，会发生什么)
- 灵魂拷问模式，(①启动杠精模式②先写方案，再模拟杠精从*个角度狂喷，最后给出V2版方案)，
- 玄学编程(，，，带点蝉意)
- 驯服转业话痨，(说人话！)
- 人设粘贴术，
- 启动老板思维(如果你是，，，你会怎么骂这个方案)
- 过滤废话，(问题，+删掉所有正确的废话，只留能落地的建议)



高性能服务设计原则
====================


高并发原则
------------

无状态: 
拆分:
服务化
消息队列
缓存:

高可用原则
------------

降级:
限流
切流量
可回滚







---

**浏览器隐私保护技术深度解析：从无痕模式到DoH**

在当今数字化时代，隐私保护已成为用户的核心诉求之一。浏览器作为互联网的主要入口，其隐私功能（如无痕模式、加密DNS等）的设计直接关系到用户数据的安全性。本文将系统解析浏览器隐私保护的核心技术，涵盖**无痕模式实现原理**、**DNS与SSL会话隔离机制**、**浏览器DNS缓存**及**DNS-over-HTTPS（DoH）**，并探讨其局限性与扩展方案。

---

### **一、无痕模式：本地痕迹的临时隔离**

无痕模式（如Chrome隐身模式、Firefox隐私窗口）并非完全匿名，但其通过以下设计实现**本地数据零残留**：

#### **1. 会话隔离与数据清理**
• **独立进程与存储**：每个无痕窗口创建独立的浏览器上下文，与普通模式隔离。Cookie、LocalStorage等数据仅存储在内存中，窗口关闭后自动销毁。
• **禁止加载历史数据**：无痕模式不读取普通模式的历史记录、密码等持久化数据。
• **扩展限制**：默认禁用浏览器扩展，防止插件泄露隐私（需用户手动授权）。

#### **2. 网络行为控制**
• **禁用预测服务**：关闭预加载页面、自动填充等功能。
• **DNS与SSL隔离**（后文详述）：防止通过DNS缓存或SSL会话关联用户身份。

#### **3. 局限性**
• **IP地址暴露**：ISP或网站仍可追踪用户真实IP。
• **指纹识别**：浏览器指纹（设备型号、屏幕分辨率等）仍可能泄露身份。
• **下载文件留存**：用户主动下载的文件不会自动删除。

---

### **二、DNS缓存隔离：浏览器与操作系统的博弈**

#### **1. 多级DNS缓存架构**
• **浏览器缓存**：现代浏览器（如Chrome、Firefox）在内存中维护独立DNS缓存，优先于系统缓存查询，以提升性能和隐私。
  • **示例**：Chrome通过`HostResolverCache`管理缓存，可通过`chrome://net-internals/#dns`查看。
• **操作系统缓存**：系统级服务（如Windows的DNS Client）缓存全局DNS记录。
• **网络缓存**：路由器或ISP的DNS服务器可能保留历史记录。

#### **2. 无痕模式的特殊处理**
• **禁用浏览器缓存**：每次DNS查询均重新解析，避免复用历史记录。
• **绕过系统缓存**：部分浏览器（如Firefox）直接向DoH服务器发起新请求，忽略本地系统缓存。
• **强制加密**：优先使用DNS-over-HTTPS（DoH），防止网络窃听。

#### **3. 验证方法**
• **浏览器开发者工具**：通过Chrome的`DNS Lookup`时间或Firefox的`about:networking#dns`分析缓存命中。
• **系统命令**：`nslookup`或`dig`仅反映系统级缓存，与浏览器缓存可能不一致。

---

### **三、SSL/TLS会话隔离：防御协议层追踪**

#### **1. SSL会话复用的风险**
传统浏览器会缓存SSL会话ID或会话票据（Session Tickets），以加速HTTPS连接。若普通模式与无痕模式共享会话状态，攻击者可能通过会话ID关联用户行为。

#### **2. 隔离机制**
• **独立会话缓存**：无痕模式维护独立的SSL会话票据、会话ID和证书验证结果。
• **强制完全握手**：部分场景下禁止复用会话密钥，要求重新协商TLS参数。
• **证书缓存隔离**：独立存储OCSP（在线证书状态协议）响应，防止证书错误状态泄漏。

#### **3. 浏览器实现差异**
• **Chrome**：从进程级别隔离SSL状态。
• **Firefox**：通过`privacy.firstparty.isolate`严格隔离跨域会话。
• **Safari**：基于标签页的进程隔离，天然实现SSL会话独立。

---

### **四、DNS-over-HTTPS（DoH）：加密DNS的革命**

#### **1. 核心原理**
• **协议封装**：将DNS查询封装在HTTPS中，通过TLS加密传输。
• **端口伪装**：使用443端口（标准HTTPS），绕过传统DNS的53端口监控。

#### **2. 核心优势**
• **隐私保护**：加密查询内容，防止ISP或中间人窃听。
• **抗劫持**：TLS证书验证防止DNS响应篡改。
• **抗审查**：难以被防火墙识别和屏蔽。

#### **3. 争议与挑战**
• **中心化风险**：依赖少数提供商（如Cloudflare、Google），可能形成数据垄断。
• **企业网络管理**：绕过本地DNS策略，影响内网域名解析。
• **调试困难**：加密后网络故障排查复杂度增加。

#### **4. 配置实践**
• **浏览器启用**（以Firefox为例）：设置 → 网络设置 → 启用DoH，选择提供商。
• **操作系统级**（Windows 11/Android 9+）：支持全局DoH配置。

---

### **五、隐私保护的未来：超越无痕模式**

#### **1. 技术融合**
• **DoH + ECH（Encrypted Client Hello）**：加密TLS握手中的SNI（Server Name Indication），彻底隐藏访问域名。
• **Tor与VPN集成**：通过多层代理隐匿IP地址。
• **反指纹技术**：随机化浏览器指纹参数（如Canvas哈希、WebGL渲染器）。

#### **2. 企业级方案**
• **零信任网络**：基于持续身份验证的动态访问控制。
• **沙盒浏览器**：通过虚拟机或容器隔离高风险访问行为。

#### **3. 用户实践建议**
• **组合工具**：无痕模式 + DoH + VPN + 反指纹插件（如Canvas Blocker）。
• **定期清理**：手动清除浏览器与系统DNS缓存。
• **选择可信DNS**：优先使用隐私友好的DoH提供商（如Quad9、AdGuard）。

---

### **结语**

浏览器的隐私保护功能（如无痕模式、DoH）通过**数据隔离、加密传输、自动清理**等机制，显著提升了用户本地数据的安全性。然而，其本质仍是“防君子不防小人”，无法对抗网络层的IP追踪或高级指纹识别。真正的匿名浏览需结合网络层（Tor/VPN）、协议层（DoH/ECH）和应用层（反指纹）的多维防御。技术不断演进，隐私保护注定是一场持久战，唯有理解原理并灵活运用工具，方能在数字世界中守护自身数据主权。