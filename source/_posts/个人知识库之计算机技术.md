---
title: 个人知识库之计算机技术
math: false
date: 2010-01-01 12:34:56
categories: 个人知识库
tags:
  - 个人知识库
  - Java
  - Go
  - 数据库
cover_picture:
---


人脑的容量有限，为了在有限的脑容量中高效的存储更多的知识，需要对知识进行归纳整理，变成自己的文章。但是并不是所有的知识都能够变成文章，出于篇幅、与其他知识点的关联等原因，很多知识当前还处于一种零散状态。

为了更有效的管理这些零散知识，现在将它们都存储在博客中的这个模块之中。当某些知识变成了一种常识或者许多知识积累了足够的信息量能够写一篇文章，则这些知识就会从这里删除。


- [========计算机类一般性知识========](#计算机类一般性知识)
- [Git常用前缀](#git常用前缀)
- [ClickHouse](#clickhouse)
- [Sqlite显示表头](#sqlite显示表头)
- [Siphash算法](#siphash算法)
- [前端校验和后端校验](#前端校验和后端校验)
- [x86-64 Core体系结构历史](#x86-64-core体系结构历史)
- [SSH隧道](#ssh隧道)
- [========Go相关知识========](#go相关知识)
- [golang-open-source-projects](#golang-open-source-projects)
- [Go值得关注的开源项目](#go值得关注的开源项目)
  - [Go语言小工具](#go语言小工具)
  - [Go语言相关库](#go语言相关库)
  - [Go项目](#go项目)
- [========Python相关知识========](#python相关知识)
  - [Flask安全文档](#flask安全文档)
- [========Java相关知识========](#java相关知识)
- [关于Java开发的一些思考](#关于java开发的一些思考)
- [一些Java对象的名称](#一些java对象的名称)
- [序列化ID](#序列化id)
- [手动检查Null](#手动检查null)
- [JVM常用参数](#jvm常用参数)
- [Java删除文件](#java删除文件)
- [Apache fileupload 无法提取参数](#apache-fileupload-无法提取参数)
- [========MyBatis源码阅读知识点========](#mybatis源码阅读知识点)
- [学习的目标](#学习的目标)
- [其他可以参考的优质开源项目](#其他可以参考的优质开源项目)
- [MyBatis的功能与实现原理](#mybatis的功能与实现原理)
- [源码阅读的一些技巧](#源码阅读的一些技巧)
- [MyBatis包划分](#mybatis包划分)
- [========Protobuf相关知识========](#protobuf相关知识)
- [protobuf简介](#protobuf简介)
  - [类型](#类型)
- [protobuf命名冲突解决方案](#protobuf命名冲突解决方案)
- [========Nginx相关知识========](#nginx相关知识)
- [========有趣的项目推荐========](#有趣的项目推荐)
- [Github使用](#github使用)
  - [免费开发环境](#免费开发环境)




========计算机类一般性知识========
-------------------------------------


Git常用前缀
--------------

- feat: 新功能、新特性
- fix: 修改 bug
- perf: 更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化）
- refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）
- docs: 文档修改
- style: 代码格式修改, 注意不是 css 修改（例如分号修改）
- test: 测试用例新增、修改
- build: 影响项目构建或依赖项修改
- revert: 恢复上一次提交
- ci: 持续集成相关文件修改
- chore: 其他修改（不在上述类型中的修改）
- release: 发布新版本
- workflow: 工作流相关文件修改



ClickHouse
----------------

ClickHouse是一种开源的分布式列式数据库管理系统（DBMS），专为处理大规模数据分析和数据仓库工作负载而设计。它是由俄罗斯的Yandex开发，并于2016年开源发布。

ClickHouse的设计目标是提供高性能的数据查询和分析能力，特别适用于处理大规模数据集和复杂查询。它采用了列式存储结构，这意味着数据按列而不是按行存储，这在分析场景下可以提供更高的查询性能。此外，ClickHouse还采用了多级压缩和向量化查询等技术，进一步提升了查询速度。

ClickHouse具有以下几个主要特点：

1. 高性能：ClickHouse在大规模数据集上具有出色的查询性能。它可以并行处理大量数据，支持高吞吐量和低延迟的查询操作。

2. 可扩展性：ClickHouse是一个分布式系统，可以水平扩展到多个节点，以处理大量数据和并发查询。它支持数据的分区和复制，可以在集群中实现高可用性和容错性。

3. 实时数据插入：尽管ClickHouse主要用于数据分析，但它也支持实时数据插入。它提供了高效的批量数据导入接口和实时数据流式传输接口，可以满足实时数据分析的需求。

4. SQL兼容性：ClickHouse支持标准的SQL查询语言，并提供了丰富的查询功能，包括聚合函数、窗口函数、子查询等。这使得开发人员可以使用熟悉的SQL语法进行数据分析和查询。

5. 灵活的数据模型：ClickHouse支持动态和静态数据模型，可以处理各种数据类型和复杂的数据结构。它还提供了高级的数据压缩和索引技术，可以有效地存储和查询大规模数据。

ClickHouse在许多大型互联网公司和数据驱动型企业中被广泛应用，用于数据分析、日志分析、实时报表和数据仓库等场景。它的高性能和可扩展性使得它成为处理大数据分析任务的理想选择。同时，由于其开源的特性，ClickHouse也得到了一个活跃的社区支持，并不断发展和改进。

> 云产品也太贵了, 根本买不起(包月需要1000+元, 按量付费每小时8+元). 


Sqlite显示表头
-----------------

默认情况下执行select语句只能得到`|`分割的数据, 如果数据比较多, 这种格式就不够直观. 可以通过如下的指令启用表头和以行模式展示数据.

```
.head on
.mode column
```

Siphash算法
---------------


SipHash是由BLAKE算法的设计者Jean-Philippe Aumasson等人于2012年设计的，它是一类针对短消息设计的伪随机函数族，可用于消息认证，用途一般与MAC算法相似。

SipHash算法通过让输出随机化，能够有效减缓哈希洪水攻击凭借这一点，它逐渐成为Ruby、Python、Rust等语言默认的Hash表实现的一部分。

- [简述SipHash算法](https://www.jiamisoft.com/blog/33725-siphash.html)
- [SipHash Wikipedia](https://en.wikipedia.org/wiki/SipHash)



前端校验和后端校验
--------------------------

前端校验的目的是防止用户错误输入。 后端校验的目的是方式恶意攻击。

所以一些关键的校验既需要前端校验也需要后端校验



x86-64 Core体系结构历史
-----------------------

x86-64处理器是对x86-32处理器的扩展. 第一个支持x86-32的处理器是1985年推出的Intel 80386微处理器. 80386是对16位体系的80286的扩展, 具有32位寄存器和4GB虚拟地址空间, 使用一个独立的, 称为80387的浮点单元进行浮点运算.

1993年推出的奔腾CPU基于P5架构, 支持MMX技术, 能够对64位大小的寄存处执行单指令多数据(SIMD操作. 1995年推出P6架构, 并在1997年推出的奔腾II中引入三路超标量设计, 使得CPU能够平均在每个周期内解码, 分派和执行三条不同的指令. 此外还引入了无序指令执行, 改进的分支预测等优化.

1999年推出的奔腾III也基于P6架构, 并且支持一种称为 Streaming SIMD Extension, SSE的指令集, 从而能够对8个128位的寄存处进行操作. 2006年, Intel推出Core架构, 支持SSE3和SSE4.1指令集. 2008年推出Nehalem架构, 再次引入超线程技术并支持SSE4.2指令集. 2011年推出Sandy Bridge架构, 引入一种新得SIMD技术, 称为Advanced Vector Extension, AVX. 2013年推出Haswell架构, 支持AVX2指令集和FMA(乘法加法融合)操作. 2017年推出的Skylake-X架构支持了AVX-512指令集, 能够操作512位的寄存器.

与此同期, AMD在2003推出一系列基于K8架构的CPU, 能够支持MMX, SSE和SSE2指令集. 2007年推出K10架构, 支持一种对SSE的扩展指令集SSE4a. 2011年推出Bulldozer架构, 支持SSE3, SSE4.1, SSE4.2, SSE4a和AVX指令集.2017年推出Zen架构, 支持AVX2指令集.

- [The History Of Intel CPUs: Updated!](https://www.tomshardware.com/picturestory/710-history-of-intel-cpus.html)




SSH隧道
--------------------

- [SSH隧道：端口转发功能详解 ](https://www.cnblogs.com/f-ck-need-u/p/10482832.html)



========Go相关知识========
------------------------------



golang-open-source-projects
----------------------------------

- https://github.com/hackstoic/golang-open-source-projects

这个项目可以理解为针对互联网IT人打造的中文版awesome-go。已有的awesome-go项目， 汇总了很多go开源项目， 但存在的问题是收集太全了， 而且每个项目没有详细描述。

本项目作为awesome-go的一个扩展，根据go语言中文社区提供的资料，还有互联网企业架构设计中的常见组件分类， 共精心挑选了154个开源项目（项目不限于在github开源的项目）， 分成以下17个大类。

项目初衷是帮助到那些想学习和借鉴优秀golang开源项目， 和在互联网架构设计时期望快速寻找合适轮子的人。

ps: 以下项目star数均大于100，且会定期检查项目的url，剔除无效链接。 每个分类下的项目会按照star数从高到低进行排列。



Go值得关注的开源项目
---------------------------

### Go语言小工具

- 解析崩溃报告的小工具: [GitHub - maruel/panicparse: Crash your app in style (Golang)](https://github.com/maruel/panicparse)
- 监控TCP流量的工具: [GitHub - kevwan/tproxy: A cli tool to proxy and analyze TCP connections.](https://github.com/kevwan/tproxy)
- Watch指令的替代品: [GitHub - sachaos/viddy: 👀 A modern watch command. Time machine and pager etc.](https://github.com/sachaos/viddy)
- 压力测试工具: [GitHub - ddosify/ddosify: High-performance load testing tool, written in Golang. For distributed and Geo-targeted load testing: Ddosify Cloud - https://ddosify.com 🚀](https://github.com/ddosify/ddosify)


### Go语言相关库

- 函数式编程库: [GitHub - samber/mo: 🦄  Monads and popular FP abstractions, powered by Go 1.18+ Generics (Option, Result, Either...)](https://github.com/samber/mo)
- 数据结构库: [GitHub - line/garr: Collection of high performance, thread-safe, lock-free go data structures](https://github.com/line/garr)
- 缓存库: [GitHub - muesli/cache2go: Concurrency-safe Go caching library with expiration capabilities and access counters](https://github.com/muesli/cache2go)

### Go项目

- 全文检索工具: [GitHub - newpanjing/gofound: GoFound GoLang Full text search go语言全文检索引擎，毫秒级查询。 使用使用http接口调用，集成Admin管理界面，任何系统都可以使用。](https://github.com/newpanjing/gofound)
- SFTP服务: [GitHub - drakkan/sftpgo: Fully featured and highly configurable SFTP server with optional HTTP/S, FTP/S and WebDAV support - S3, Google Cloud Storage, Azure Blob](https://github.com/drakkan/sftpgo)




========Python相关知识========
------------------------------

### Flask安全文档

- https://pythonhosted.org/Flask-Security/



========Java相关知识========
------------------------------





关于Java开发的一些思考
----------------------


在Java Web开发过程中，相比于直接使用MyBatis并手写基础的SQL语句，还是直接使用MyBatis-Plus更好，尤其在涉及字段变化的时候，能够减少很多维护的负担。

一个Java Web项目，即使什么操作也不做，也需要大约200M内存空间，而与此相对的，Go和Python即使实现了一个稍微有些复杂的后端，可能内存还是能够控制在50M以内，因此项目规模决定了是否使用Java。否则开发也费劲，服务器也承受不了。



一些Java对象的名称
-------------------

名称| 全称                 | 含义
---|----------------------|-------------------------------------
PO | Persistent Object    | 对应数据库记录的Java对象
VO | Value Object         | 业务层之间传递数据的的对象
DAO| Data Access Object   | 控制数据库访问的对象, 通常与PO结合
DTO| Data Transfer Object | 数据传输对象, 与数据库传递数据
BO | Business Object      | 封装业务逻辑的对象, 调用DAO的方法   



序列化ID
--------------

serialVersionUID 用于标记序列化类的版本, 如果对类进行了修改, 那么也应该同步的修改serialVersionUID. IDEA可以直接提供随机值.


手动检查Null
-----------------

手动检查是否为Null, 并手动抛出NullPointException可以视为一种防御性编程, 即如果可能发生错误, 则应该尽可能早的产生.




JVM常用参数
----------------

参数                        | 含义
----------------------------|------------------------------------
-Xms                        | 设置初始堆大小
-Xmx                        | 设置最大堆大小
-XX:+PrintCommandLineFlags  | 打印设置的参数(包括默认参数)



实际上JVM会根据设备可用的内存数量来调整默认使用的垃圾回收算法. 例如在我的服务器上(1GB内存)和开发机器上(16GB内存)分别打印默认的参数. 其结果如下所示:


```
-XX:InitialHeapSize=16071680 -XX:MaxHeapSize=257146880 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC 
openjdk 11.0.10 2021-01-19
OpenJDK Runtime Environment 18.9 (build 11.0.10+9)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.10+9, mixed mode, sharing)
```

```
-XX:G1ConcRefinementThreads=8 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=267607488 -XX:MaxHeapSize=4281719808 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation
java 11.0.4 2019-07-16 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.4+10-LTS)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.4+10-LTS, mixed mode)
```

由于服务器上内存较少, 因此默认采取最简单的Serial系列垃圾回收器, 从而节省内存消耗. 而开发机器上内存比较充足, 因此采取了性能更好的G1垃圾收集器.



Java删除文件
-----------------

曾经有过使用Java删除文件的经历, 但是偶尔会遇到删除失败. 即使用`file.delete()`函数时, 返回false. 因为这个函数并不抛异常, 所以并不清楚是什么原因导致了这一问题. 如果查看`file.delete()`的源代码, 可以发现这个函数的注释上写了如下的语句:
``` Java
    /**
     * <p> Note that the {@link java.nio.file.Files} class defines the {@link
     * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}
     * when a file cannot be deleted. This is useful for error reporting and to
     * diagnose why a file cannot be deleted.
     */

```
上面这段注释指明, 可以使用`java.nio.file.Files`类的静态方法`delete(Path)`来删除文件, 这个函数会抛出异常来指明为什么删除失败. 注意到`delete(Path)`方法需要传入一个`Path`类作为参数, 而`File`类正好有一个`toPath()`方法可以将一个`File`类转化为`Path`类. 

因此在明白了这些函数以后, 可以将原来的代码中的相关删除操作换成这个会抛异常的方法, 然后根据异常信息来确定具体的异常原因. 替换后, 抛出异常指出我想要删除的文件被正在被另外一个程序使用, 进程无法访问. 检查了一下代码的其他部分, 很快就发现了之前读取这个文件的文件流没有关闭. 因此在原来的代码中加入了关闭流的操作后, 就可以顺利的将文件删除了. 

值得一提的是, 同样的代码, 在Linux平台上, 似乎并不会因为文件流没有关闭就导致文件无法被删除. 但是因为Linux平台上使用的编译器和JVM与Windows平台不同, 因此也不能确定这一差异是编译器导致的还是JVM或者操作系统导致的. 如果下次有机会, 可能会进一步探索一下其中的差异. 


Apache fileupload 无法提取参数
----------------------------------

之前使用了Apache的fildupload实现了文件上传功能, 后来发现通过表单传递的参数无法通过`request.getParameter()`获得. 通过查阅[Apache CommonIO文档](https://commons.apache.org/proper/commons-fileupload/using.html)可知, 使用以下方法获得参数

``` java
// Process a regular form field
if (item.isFormField()) {
    String name = item.getFieldName();
    String value = item.getString();
    ...
}
```

其中item通过以下方法获得

``` java
 Map<String, List<FileItem>> formItemMaps =upload.parseParameterMap(request);
               
if (formItemMaps != null && formItemMaps.size() > 0) {
    for (String name : formItemMaps.keySet()) {      
        List<FileItem> itemList = formItemMaps.get(name);
        for(FileItem item:itemList) {
           // 在这里处理item
        }
    }
}
```

注意: 现在如果仅仅是文件上传, 其实并不需要使用CommonIO, Tomcat本身也支持有关功能.


========MyBatis源码阅读知识点========
--------------------------------------------------



学习的目标
--------------

在阅读一个项目的过程中，应该抱着如下的几个目标：

1. 理解项目的实现原理
2. 学习成熟项目的架构方案
3. 学习可靠且巧妙的实现技巧
4. 补足自身知识盲点

其他可以参考的优质开源项目
-------------------------

- dubbo
- netty
- spring-boot
- fastjson
- kafka


MyBatis的功能与实现原理
----------------------

首先要明确一点，基于Java提供的JDBC接口，仅通过调用这些接口即可实现数据库的所有功能。因此MyBatis实际上并不需要实现任何与数据库相关的代码，这些代码应该由对应的驱动包实现。

所以MyBatis的主要功能是SQL语句拼接，接口绑定，缓存等上层功能，而整个库里面的大部分代码的作用也是实现这些功能。


源码阅读的一些技巧
-------------------


1. 根据项目的包结构大致划分每个包的功能
2. 从外围的基础功能包开始阅读，逐步阅读核心的包

因为外围的基础包的依赖比较少，因此比较容易理解其中的功能。而项目的核心包往往依赖了众多基础包，因此阅读这些包的代码之前也需要先了解核心包的代码。

MyBatis包划分
-------------

根据每个包的名称，以及大致对代码的浏览，可以做出如下的划分

- 基础功能包：exceptions / reflection / annotations / lang / type / io / logging / parsing
- 配置解析包：binding / builder / mapping / scripting / datasource
- 核心操作包：jdbc / cache / transaction / cursor / executor / session / plugin

MyBatis中有大量的代码都是解析相关的。




========Protobuf相关知识========
------------------------------



protobuf是一种将结构化数据序列化的机制, 可用于内部设备通信或存储. 与JSON格式相比, 基于protobuf协议的二进制文件体积更小, 解析速度更快.




protobuf简介
----------------

### 类型

| 类型                                 | 解释                               |
| ------------------------------------ | ---------------------------------- |
| float, double                        | 浮点数                             |
| int32, int64, uint32, uint64         | 整数，但不适合编码较大的数字和负数 |
| sint32, sint64                       | 针对负数进行优化的整数类型         |
| fixed32, fixed64, sfixed32, sfixed64 | 更适合大数字的有符号数或无符号数   |
| bool                                 | 布尔值                             |
| string                               | 任意的UTF-8字符串                  |
| byte                                 | 任意的字节                         |

protobuf对数字存储进行了优化，一个数字越小则存储长度越短。由于计算机使用补码表示负数，因此通常情况下负数将使用多个字节表示。为了优化这种情况，sint类型使用交叉的方式表示，绝对值较小的负数依然可以获得较短的存储长度。

- [官方文档](https://developers.google.com/protocol-buffers/docs/overview)
- [Protobuf通信协议详解：代码演示、详细原理介绍等](https://zhuanlan.zhihu.com/p/141415216)
- [proto2格式说明](https://developers.google.com/protocol-buffers/docs/proto)
- [proto3格式说明](https://developers.google.com/protocol-buffers/docs/proto3)



protobuf命名冲突解决方案
------------------------

对于PB的namespace, 规范要求每个PB都是全局唯一的. 如果设计不合理就会导致PB名称冲突, 对于高版本的依赖库, Go语言在启动时会直接painc, 导致系统无法启动. 

对于上述问题, 可以通过降级依赖版本临时解决:

```go
replace (
	github.com/golang/protobuf => github.com/golang/protobuf v1.4.3
	google.golang.org/protobuf => google.golang.org/protobuf v1.25.0
)
```



========Nginx相关知识========
------------------------------



- [nginx的location匹配规则, 泣血总结](https://blog.csdn.net/luoyang_java/article/details/83507193)
- [nginx配置location匹配顺序总结](https://blog.csdn.net/agonie201218/article/details/92795522)


========有趣的项目推荐========
------------------------------
- [基于命令行的浏览器](https://fathy.fr/carbonyl#drawing)


Github使用
-----------


### 免费开发环境

每月可免费使用120核心小时的服务器资源.  停止运行后, 不计算核心小时资源, 仅计算存储资源. 
 
默认启用2核心服务器, 可使用60小时, 平均每天可使用2小时. 30min无操作自动关闭, 几乎等于无限制使用.
 
 
- [配额说明](https://docs.github.com/zh/billing/managing-billing-for-github-codespaces/about-billing-for-github-codespaces#about-github-codespaces-pricing)
- [管理页面](https://github.com/codespaces)
 
