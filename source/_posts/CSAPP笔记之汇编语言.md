---
title: CSAPP笔记之汇编语言
date: 2020-08-10 12:06:34
categories: 
tags:
    - 操作系统
    - 汇编语言
cover_picture: images/CSAPP.jpg
---



汇编格式差异
------------------

对于GCC编译器, 其汇编代码默认AT&T格式. 通常情况下, 计算机的汇编语言课程仅讲解Intel格式的汇编代码, 因此对于AT&T格式可能较为陌生. 两种格式的主要区别如下:


区别        | Intel格式             | AT&T格式          | 说明
------------|----------------------|-------------------|--------------------------------------------
寄存器      | eax                   | %eax              | Intel格式无前缀, AT&T格式始终使用%前缀
立即数      | 6                     | $6                | Intel格式中数字就是数字
内存地址    | [0x1234]              | 0x1234            | AT&T格式格式中数字默认是地址
操作数大小  | 使用数据类型修饰符     | 指令后最后一个字母  | `mov byte[0x123], eax` `movb eax, 0x123`

两种格式的主要差别如下:
- 在Intel格式中, 指令顺序为`op dst, src`. AT&T格式相反, 为`op src, dst`
- 在Intel格式中, 数字就是立即数, 如果表示内存地址, 需要使用`[]`. 而AT&T格式相反, 数字就是内存地址, 如果表示立即数, 需要使用`$`前缀.



指令后缀
----------------

与X86汇编相比, X64汇编的一个显著区别是增加了对64bit数据的操作, 对于所有的数据传输指令, 都可以添加指令后缀来明确具体数据的具体长度, 后缀的关系如下表所示

C语言声明    | Intel数据类型       | 汇编后缀  | 字节长度
------------|---------------------|-----------|---------
char        | 字节(byte)          | b         | 1
short       | 字(word)            | w         | 2
int         | 双字(double word)   | l         | 4
long        | 四字(quad word)     | q         | 8
char*       | 四字(quad word)     | q         | 8
float       | 单精度(single)      | s         | 4
double      | 双精度(double)      | l         | 8

双字使用`l`作为后缀, 因此双字也被认为是一种长字节(long word). 浮点数指令和整数指令后缀有一些冲突, 但实际上由于浮点数指令是一套单独的指令, 因此并不会构成冲突.



寄存器结构
--------------

X64寄存器数量和寄存器长度都在X86的基础上再次翻倍, 每个寄存器都是64位长度, 并且新加入的8个寄存器, 新加入的寄存器分别命名为%r8~%r15. 所有寄存器和使用规则如下表所示

寄存器  | 使用规则      | 寄存器  | 使用规则
---------|--------------|---------|-----------------
%rax     | 返回值        | %r8     | 第5个参数
%rbx     | 被调用者保存  | %r9      | 第6个参数
%rcx     | 第4个参数     | %r10    | 调用者保存
%rdx     | 第3个参数     | %r11    | 调用者保存
%rsi     | 第2个参数     | %r12    | 被调用者保存
%rdi     | 第1个参数     | %r13    | 被调用者保存
%rbp     | 被调用者保存   | %r14    | 被调用者保存
%rps     | 栈指针        | %r15    | 被调用者保存

与X86汇编一样, 可以通过类似%eax, %ax, %ah, %al的方式访问原有的8个寄存器的低位部分. 对于新增的寄存器, 也可以使用类似%r8d, %r8w, %r8b的方式访问r8寄存器的低32位, 低16位和低8位.

由于寄存器数量有明显的增加, 因此与X86相比, 一个显著的变化就是大部分时候的函数调用不需要再进行参数入栈的操作, 大部分时候函数调用的参数都可以直接用寄存器传递.

> 将数据移动到寄存器时, 如果移动的数据是1字节或2字节, 则寄存器的高位不变. 如果移动的数据是4字节, 则将高位数据置零


操作数指示符
---------------

格式              | 名称                    | 格式              | 名称       
-----------------|---------------------------|-------------------|----------------------------   
`$0x1234`        | 立即数                    | `%rax`            | 取%rax的值   
`0x1234`         | 绝对寻址                  | `(%rax)`          | 取%rax对应内存
`-4(%rbx)`       | 取%rax加上偏移的内存值     | `12(%rbx, %rax)` | 取寄存器与立即数之和的内存地址




数据传送指令
---------------

`mov`指令结合四种长度后缀可以表示四种不同长度的数据传输指令, 即`movb`, `movw`, `movl`和`movq`. `mov`指令既可以在寄存器之间传送数据, 也可以将立即数传入寄存器. 但`movq`指令只能接受32位的有符号立即数, 将其进行**符号扩展**到64位, 并传入寄存器. 如果需要传送64位立即数, 则需要使用`movabsq`指令进行绝对传送.

`mov`指令有两种变形, 分别是`movz`和`movs`. 两个指令分别表示零扩展和符号扩展. 例如`movzbl`表示将一个字节的数据先进行零扩展变为一个双字长度, 然后传送到目标位置, `movzwq`表示将一个字长度的数据进行零扩展变成四字长度后传送到目标位置. 

数据传送指令虽然指定了数据的长度, 但不能与操作的寄存器发生冲突. 例如`movl %rax, (%rbx)` 似乎希望传送`%rax`的两个字节到内存, 但并没有这种用法, 如果需要传送低位, 只能使用`%eax`替换.

> `cltq`指令是`movslq %eax %rax`指令的简化指令, 表示将`%eax`的数据符号扩展到`%rax`


栈操作
-----------------

栈操作与X86汇编没有太大区别, 只是入栈和出栈的基本单元的大小都设置为8字节.


指令    | 效果
--------|-----------------------------
pushq S | 将指定数据入栈
popq  D | 将栈中数据弹入指定寄存器



算数指令
------------

大部分指令在加上后缀后都有四个版本, 例如`addb`, `addw`, `addl`和`addq`. 后缀含义都是一致的, 因此下面使用大写表示指令不包含后缀的部分

指令    | 含义
--------|----------------------
leaq    | 加载有效地址
INC / DEC   | 加减一
NEG / NOT   | 取负/取反
ADD/SUB/IMUL | 加/减/乘 运算
XOR/OR/AND | 异或/或/与 操作
SAL/SHL     | 算数左移 / 逻辑左移
SAR / SHR   | 算数右移 / 逻辑右移

> `SHR -> SHift Right`  `SAR -> Shift Arithmetic Right`

`leaq`指令表示加载变量的地址, 第一个操作数是一个内存位置, `leaq`指令将该内存位置的地址写入第二个参数.

由于地址表示有多种方式, 因此`leaq`指令相当于一个简易的算数运算器, 可以高效地执行特定的加法与乘法的组合, 因此可实现特定的计算, 例如如下的C语言代码, 

```c
long scale(long x, long y, long z) {
    long t = x + 4* y + 12 *z;
    return t;
}
```
在O2优化等级下, 其汇编代码核心逻辑如下

```s
	leaq	(%rdi,%rsi,4), %rax ; x + 4 * y
	leaq	(%rdx,%rdx,2), %rdx ; z + 2 * z
	leaq	(%rax,%rdx,4), %rax ; (x + 4 * y) + 4* (3*z)
```

根据函数传参规则有 `%rdi -> x`; ` %rsi -> y`;  `%rdx -> z`, 可以很容易的验证上述汇编代码与原始的C代码逻辑一致.

> 编译器的优化能力果真是难以置信



条件码
-----------

CPU维护如下的一些条件码, 这些条件码均指示最近一次操作的一些特征, 具体如下

名称| 含义      | 效果
----|----------|------------------
CF  | 进位标志  | 是否产生进位
ZF  | 零标志    | 是否产生0
SF  | 符号标志  | 是否产生负数
OF  | 溢出标志  | 是否产生补码溢出

针对上述标志, 有两个常用的指令

指令        | 含义      | 解释
------------|----------|-------------
CMP S1, S2 | S2 - S1 | 比较 
TEST S1, S2 | S1 & S2 | 测试