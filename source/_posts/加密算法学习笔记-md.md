---
title: 加密算法学习笔记.md
math: false
date: 2025-11-23 12:49:05
categories: 
tags:
    - 密码学
cover_picture: images/openssl.png
---

最近回顾了自己读大学的时候做的一些加解密工具, 发现已经使用不同的语言实现过很多次AES加解密逻辑了. 虽然基于各种编程语言自带的加密算法库, 实现一个加解密功能并不算复杂, 但是其中的许多实现逻辑比较繁琐, 处理不当容易产生安全问题. 

正好这个时候想到Unix设计哲学里面的一个工具只做一件事, 于是就查询了一下有无那个工具能够在命令行上面搞定加解密的事情. 经过简单地查询, 可以发现一个名叫`openssl`的工具已经很好的实现了相关的功能. 因此本文将基于此工具讨论一些常见的加密算法, 后续有需要加解密的场景就可以直接使用此工具来实现, 而不必重复造轮子了.




对称加密
---------------

对称加密的经典算法是AES算法, `openssl`内置了多种AES算法的模式, 具体对比如下


# AES工作模式详细对比表

| 模式    | 全称                       | 主要原理                                 | 认证加密   | 并行加密   | 需要填充   | 错误传播     | IV要求       | 推荐程度     | 典型场景           |
| ------- | -------------------------- | ---------------------------------------- | ---------- | ---------- | ---------- | ------------ | ------------ | ------------ | ------------------ |
| **ECB** | Electronic Codebook        | 每个数据块独立加密，相同明文产生相同密文 | ❌ 无       | ✅ 支持     | ✅ 需要     | 块内传播     | ❌ 无需       | ❌ 永不使用   | 基本不应使用       |
| **CBC** | Cipher Block Chaining      | 每个块与前一密文块异或后再加密           | ❌ 无       | ❌ 不支持   | ✅ 需要     | 影响后续块   | ✅ 随机唯一   | ✅ 传统兼容   | 文件加密、传统协议 |
| **CTR** | Counter                    | 使用计数器生成密钥流，与明文异或         | ❌ 无       | ✅ 支持     | ❌ 不需要   | 仅影响当前位 | ✅ 唯一计数器 | ✅✅ 推荐      | 磁盘加密、大文件   |
| **OFB** | Output Feedback            | 将块密码转换为自同步流密码               | ❌ 无       | ❌ 不支持   | ❌ 不需要   | 仅影响当前位 | ✅ 随机唯一   | ⚠️ 一般       | 错误敏感场景       |
| **CFB** | Cipher Feedback            | 将块密码转换为自同步流密码，密文反馈     | ❌ 无       | ❌ 不支持   | ❌ 不需要   | 有限传播     | ✅ 随机唯一   | ⚠️ 一般       | 字节级流加密       |
| **GCM** | Galois/Counter Mode        | CTR模式加密 + GMAC认证                   | ✅ 内置认证 | ✅ 支持     | ❌ 不需要   | 认证失败     | ✅ 随机唯一   | ✅✅✅ 强烈推荐 | TLS、现代加密      |
| **CCM** | Counter with CBC-MAC       | CTR加密 + CBC-MAC认证                    | ✅ 内置认证 | ⚠️ 有限并行 | ❌ 不需要   | 认证失败     | ✅ 随机唯一   | ✅✅ 推荐      | 无线通信、物联网   |
| **XTS** | XEX-based Tweaked Codebook | 专为磁盘加密设计，使用tweak值            | ❌ 无       | ✅ 支持     | ⚠️ 部分需要 | 仅影响扇区   | ✅ tweak值    | ✅✅ 专用场景  | 全盘加密           |

## OpenSSL命令行示例汇总

```bash
# CBC模式（兼容性好）
openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -salt -in file.txt -out file.cbc

# CTR模式（高性能，无填充）
openssl enc -aes-256-ctr -pbkdb2 -iter 100000 -salt -in file.txt -out file.ctr

# GCM模式（推荐，认证加密）
openssl enc -aes-256-gcm -pbkdf2 -iter 100000 -salt -in file.txt -out file.gcm

# 查看支持的加密算法列表
openssl enc -list
```


为什么加密过程需要使用动态盐
---------------------------

在加密系统中使用**动态盐**（每次加密随机生成的新盐）的核心原因在于它从根本上改变了攻击者的破解策略和成本模型。盐的核心使命并非保密，而是**确保唯一性**和**打破预计算**。想象一下，如果所有用户使用相同的密码“123456”，在无盐或固定盐的情况下，这些密码生成的加密密钥是完全相同的。攻击者只需针对这个单一密钥进行破解，一旦成功，所有使用该密码的账户都将沦陷。更危险的是，攻击者可以预先计算一个庞大的“密码->密钥”彩虹表，实现秒级破解。

动态盐的引入彻底瓦解了这种攻击路径。每次加密时，系统都会生成一个全新的、随机的盐值（通常16字节或更长）。即使两个用户拥有完全相同的密码，由于盐值不同，经过密钥派生函数（如PBKDF2、scrypt）处理后，产生的实际加密密钥也截然不同。这意味着：

1.  **预计算攻击失效**：攻击者无法预先计算彩虹表，因为每个加密实例使用的盐都是随机的、唯一的。为破解一个账户准备的表格对另一个账户完全无效。
2.  **批量破解成本激增**：攻击者必须为*每一个目标*单独进行暴力破解。破解100个账户的成本不再是破解1个账户的100倍，而是可能高出数千倍（因为每个目标都需要独立的计算过程）。
3.  **密钥重用风险归零**：即使某个特定“密码+盐”组合被破解，也不会泄露其他使用相同密码但不同盐值的账户。

**那么，为什么盐不需要保密？** 这看似违反直觉，实则蕴含着密码学的智慧：

1.  **盐的使命是“差异化”，而非“隐蔽”**：盐的核心价值在于其**随机性和唯一性**，而不是它的秘密性。它的存在是为了确保相同的输入（密码）产生不同的输出（密钥）。即使攻击者知道盐值（例如从存储中读取），他们仍然需要：
    *   针对*这个特定的盐值*
    *   对*可能的密码空间*
    *   进行*完整的暴力破解或字典攻击*
    这极大地增加了攻击的边际成本。
2.  **遵循Kerckhoffs原则**：现代密码学的安全应建立在**算法和密钥的保密性**上，而不是系统的晦涩性（如隐藏盐）。公开盐值符合这一原则，让安全评估更透明。
3.  **实现简单性与兼容性**：将盐与密文一起存储（例如 `salt|iv|ciphertext`）是最简单、最可靠的方式。它避免了单独管理盐的秘密通道，简化了系统设计，并确保解密时能准确获取所需的盐值。
4.  **不影响密钥强度**：盐值本身并不包含密钥信息。最终的加密强度仍由用户密码的熵值、密钥派生函数的强度以及加密算法本身决定。盐只是确保这些要素在一个独特的环境中发挥作用。

**总结来说：** 动态盐是加密系统的“扰动因子”，它通过引入强制的、公开的随机性，将每个用户的加密过程变成独立的安全堡垒。即使盐值公开，它也迫使攻击者从高效的“批量流水线作业”模式，退回到低效的“逐个手工攻坚”模式，极大地提升了系统的整体安全性。盐的公开性非但不是弱点，反而是其安全机制透明化和可验证性的体现。
