
OSI七层模型、TCP/IP4模型与TCP/IP5模型

### TCP与UDP区别

- TCP/IP是面向连接的，UDP是无连接的。
- TCP是点对点的， UDP可以单播也可以广播
- TCP有传输控制， UDP没有传输控制

### TCP三次握手和四次挥手

SYN=1 seq
SYN=1 ACK=1 seq ack
ACK=1 seq ack

FIN=1 seq 
ACK=1 seq ack
FIN=1 ACK=1 seq ack
ACK=1 squ ack




### TCP滑动窗口和拥塞控制


1. 慢开始：从一个SSIM开始，每一轮拥塞控制窗口cwin大小翻倍
2. 拥塞避免：cwin达到门限值后采取拥塞避免算法，每轮增加一个SSIM
3. 超时：发生超时后，门限值设置为超时时的窗口大小的一半，重新开始慢开始过程
4. 快重传：如果收到三个同样的ACK，立即重传下一个报文
5. 快恢复：如果发生快重传，则门限值设置为此时窗口大小的一半，并重新开始拥塞避免算法


### HTTP1.0/1.1/2.0区别

- HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
- 1.1 版本引入了持久连接和管道机制，可以复用TCP连接以及在一个链接中同时发送多个请求。
- 1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。新增了Host字段，为虚拟主机奠定基础
- 2.0版本采用二进制协议， 复用TCP连接，可以交替的相应不同的请求。使用数据流模型分割不同的请求，使得每个数据流公用一个TCP连接的同时，表现为独占连接。头部信息压缩，服务器主动推送。



### cookie和session的区别

cookie和session都是为了解决HTTP协议无状态的问题。
cookie存储在客户端，session存储在服务器端。


### DNS查询过程

### TCP协议如何保证可靠传输

1. 数据包有编号， 保证有序
2. 数据包有校验， 保证传输数据的正确
3. 传输控制：自动重传，流量控制等

- [TCP 协议如何保证可靠传输](https://segmentfault.com/a/1190000022944999)


### TCP粘包

TCP粘包本质上是对数据的边界没有了解，而不是TCP本身的问题。应用程序应该将TCP协议传输的数据视为一个字节流，自己控制每段数据的边界或者长度。


- [硬核图解|tcp为什么会粘包？背后的原因让人暖心](https://segmentfault.com/a/1190000039691657)


---------------------------------------------




### 通配符
% 匹配0个或多个字符
_ 匹配一个字符


### 并发一致性问题


### 隔离级别


#### 事务的4大特性

ACID： 原子性 一致性 隔离性 持久性


关系型数据库和非关系型数据库的区别

什么时候适合建立索引/什么时候不适合建立索引/索引失效

主键索引与唯一索引的区别

### 数据库的四大范式（函数依赖、异常和范式）

第一范式：每个列都是原子的
第二范式：一行数据中不存在部分依赖（即是否有可拆分的字段）
    - (学号，课程号，成绩，学分) -> (学号，课程号，分数)  (课程号，学分)
第三范式：消除传递依赖
BC范式：多个主属性之间消除传递依赖

- [数据库四大范式](https://www.jianshu.com/p/71563d6b121d)




### 一致性和原子性的区别

原子性： 一个事务要么完全成功，要么完全失败，不能部分执行
一致性：数据库一致的从一个状态变成另一个状态

保证原子性不能保证一致性，因为原子性不能防止多个事务之间同时修改，


### MySql中一条sql语句的执行过程

身份校验 查询缓存（8.0版本取消） 分析器 优化器  执行器

### 为什么要用redis/为什么要用缓存

提高性能  提高并发能力



### redis过期淘汰策略、持久化机制

取key的时候检查 / 随机抽取判断是否失效

RDB AOF



### redis缓存穿透/缓存击穿/缓存雪崩

穿透： 查询不存在的key，导致查询数据库
击穿： 缓存过期，导致大量线程同时查询数据库
雪崩： 大量Key同时过期




### 进程、线程和协程的区别


进程： 资源分配的最小单位，是操作系统进行资源分配和调度的一个独立单位
线程： 有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位
协程： 一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）


### 进程间通信方式

匿名管道（父子进程） 高级管道（另一个进程作为当前进程的子进程） 有名管道（允许无亲缘关系进程间的通信）
消息队列
信号量 信号
共享内存
套接字


### 进程调度算法


先到先服务
最短作业优先
高响应比优先
时间片轮转调度
最高优先级（可分抢占式和非抢占式）
多级反馈队列


- [大厂面试爱问的「调度算法」，20 张图一举拿下](https://www.cnblogs.com/xiaolincoding/p/13631224.html)




### 分页管理与分段管理的共同点和区别


共同点：
1. 分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。
2. 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。

区别：
1. 页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。
2. 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，是为了满足用户的需要。





Shell指令
----------------------

grep是文件过滤
printf是格式化输出，与C中的用法基本一致


docker ps | awk '$2=="blog"  {print $1}'

awk '{if ($1 == "foo") print "Exact match foo"; else if ($1 ~ "bar") print "Partial match bar"; else print "Baz"}' {{filename}}

可以分为条件和输出两个部分，不指定就表示全部

### 压缩和提取

tar
Archiving utility.Often combined with a compression method, such as gzip or bzip2.More information: https://www.gnu.org/software/tar.

 - [c]reate an archive and write it to a [f]ile:
   tar cf {{target.tar}} {{file1}} {{file2}} {{file3}}

 - [c]reate a g[z]ipped archive and write it to a [f]ile:
   tar czf {{target.tar.gz}} {{file1}} {{file2}} {{file3}}

 - [c]reate a g[z]ipped archive from a directory using relative paths:
   tar czf {{target.tar.gz}} --directory={{path/to/directory}} .

 - E[x]tract a (compressed) archive [f]ile into the current directory [v]erbosely:
   tar xvf {{source.tar[.gz|.bz2|.xz]}}

 - E[x]tract a (compressed) archive [f]ile into the target directory:
   tar xf {{source.tar[.gz|.bz2|.xz]}} --directory={{directory}}

 - [c]reate a compressed archive and write it to a [f]ile, using [a]rchive suffix to determine the compression program:
   tar caf {{target.tar.xz}} {{file1}} {{file2}} {{file3}}

 - Lis[t] the contents of a tar [f]ile [v]erbosely:
   tar tvf {{source.tar}}

 - E[x]tract files matching a pattern from an archive [f]ile:
   tar xf {{source.tar}} --wildcards "{{*.html}}"


### 排序

 - Sort /etc/passwd by the 3rd field of each line numerically, using ":" as a field separator:
   sort --field-separator={{:}} --key={{3n}} {{/etc/passwd}}

